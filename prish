#!/usr/bin/env bash
#==========================HEADER====================================|
#AUTOR
# Jefferson 'slackjeff' Rocha <root@slackjeff.com.br>
#
#LICENÇA
# MIT
#
#PROGRAMA
# prish - Dê voz a quem precisa.
#
#DOCUMENTAÇÃO
# Leia a documentação completa que se encontra externamente
#
#CHANGELOG
# Visualize o arquivo CHANGELOG.md para saber mais!
#====================================================================|

#================= BIBLIOTECAS
. prish.conf # Carregando arquivo de configuração do sistema

#================= CONSTANTES

PRETO='\e[30;1m'
VERMELHO='\e[31;1m'
VERDE='\e[32;1m'
AMARELO='\e[33;1m'
AZUL='\e[34;1m'
ROSA='\e[35;1m'
CIANO='\e[36;1m'
BRANCO='\e[37;1m'

VERMELHO_BRANCO='\e[37;41;1m'
AZUL_BRANCO='\e[37;44;1m'
AMARELO_PRETO='\e[30;43m'
PRETO_AMARELO='\e[33;40;1m'
VERDE_VERMELHO='\e[31;42;1m'
CYANO_PRETO='\e[30;46;1m'

FIM='\e[m'

#================= VARIÁVEIS
name='prish'              # Nome do Projeto
version='0.6a'             # Versão

#================= TEST
# Carregamento de variáveis!
# Caso as variáveis de ambiente da prish não estão
# com suas respectivas numerações/chaves por falta
# de atenção do usuário, elas carregarão como padrão definidas.
[[ "$limit_menu" =~ [0-9] ]]   ||  limit_menu="${LIMIT_MENU:-9}"
[[ "$timer" =~ [0-9] ]]        ||  timer="${TIMER:-2}"
[[ "$color_key" =~ [0-9] ]]    ||  color_key="${COLOR_KEY:-0}"
[[ "$color_number" =~ [0-9] ]] ||  color_number="${COLOR_NUMBER:-1}"
[[ "$color_text" =~ [0-9] ]]   ||  color_text="${COLOR_TEXT:-7}"

# Utilizar cores na saída?
# Se sim vamos puxar qual o valor o usuario(a) definiu
# no arquivo de configuração.
if [ "$color_key" = "0" ]; then
   case $color_number in # Fundo/cor Númerico
       1) bgmenu=${VERMELHO_BRANCO};; # Fundo Vermelho com letra Branca
       2) bgmenu=${AZUL_BRANCO};; # Fundo Azul com letra Branca
       3) bgmenu=${AMARELO_PRETO}  ;; # Fundo Amarelo com letra Preta
       4) bgmenu=${PRETO_AMARELO};; # Fundo Preto com letra Amarela
       5) bgmenu=${VERDE_VERMELHO};; # Fundo Verde com letra Vermelha
       6) bgmenu=${CYANO_PRETO};; # Fundo Cyano com letra Preta
   esac
   case $color_text in # Cor texto
      1) txtcolor=${PRETO};; # Preto
      2) txtcolor=${VERMELHO};; # Vermelho
      3) txtcolor=${VERDE};; # Verde
      4) txtcolor=${AMARELO};; # Amarelo
      5) txtcolor=${AZUL};; # Azul
      6) txtcolor=${ROSA};; # Rosa
      7) txtcolor=${CIANO};; # Ciano
      8) txtcolor=${BRANCO};; # Branco
   esac
   endcolor=${FIM} # Fechamento da cor.
fi


# Conferindo se todos os diretórios principais existem!
# Ao decorrer do program está lista é usada para ir criando
# variáveis.
dir=(
    "sons"
    "documentacao"
    "menu"
    "logo"
)

for check_dir in "${dir[@]}"; do
    [ ! -d "$check_dir" ] && { echo "Diretório '$check_dir' não foi encontrado!"; exit 1;}
done

# Verificando se as deps estão supridas
# Adicione no vetor conforme ira aumentando
# as dependencias da pri.
dep=(
   'paplay'
   'pv'
)

# Loop para varrer a array atrás das deps.
for check in "${dep[@]}"; do
    if ! type "$check" &>/dev/null; then
        echo "Falta instalar a dependência ${check}."
        exit 1
    fi
done

# Verificando qual o gênero da voz será usado.
# Se não for setado nada o padrão é o masculino.
voice=$(echo "$voice" | tr [A-Z] [a-z] ) # Tudo em lower
if [ "$voice" = "m" ]; then
    sound="${dir[0]}/masculino/"
elif [ "$voice" = "f" ]; then
    sound="${dir[0]}/feminino/"
else
    sound="${dir[0]}/masculino"
fi

#================= FUNCÕES

_PRINT() # Função de printa na tela
{
   while IFS= read view; do
      echo "$view"
   done < "$*"
}

_SLEEP() # Função para adormecer em determinados momentos.
{
   sleep "$@"
}

_MAIN() # Função que faz a rotina principal
{
   # Declarações de variaveis locais
   local menu='menu/menu.txt'

   while :; do
      # Verificando se chaves estão ligadas.
      clear # Limpa a tela ae
      i='0' # var de incremento.
      # Printando na tela
          while IFS= read -r print_me; do
             i=$((i+1))
             # Algumas verificações na linha antes de imprimir
             if [[ "$print_me" =~ ^[[:space:]]*$ ]]; then # Linha vazia?
                 { i=$((i-1));continue;}
             elif [[ ! "$print_me" =~ [a-zA-Z] ]]; then   # Não começa com Letras?
                 { i=$((i-1));continue;}
             elif [[ "$print_me" =~ ^[[:space:]]+{1,} ]]; then # Tem espaço em qualquer quantidade no inicio?
                 print_me=$(echo "$print_me" | sed 's/^[[:space:]]*/ /g')
             elif [[ "$print_me" =~ ^# ]]; then # Inicio da linha com # ? Não imprima.
                 { i=$((i-1)); continue;}
             fi
             echo -e "${bgmenu}\[ ${i} ]${endcolor} ${txtcolor} $print_me ${endcolor}" # Imprimindo com incremento.
             show_me[$i]="$print_me" # pegando no vetor todas opções
             [ "$i" = "$limit_menu" ] && break # Verficando o limite máximo do menu.
          done < "$menu"

      # Verificando se o limit_menu é maior que 9
      # Se for precisamos de duas casas númericas no STDIN.
      if [ "$limit_menu" -gt "9" ]; then
          # Limitado a 2 casas para não precisar de enter.
          read -n 2 -p $'\n' operation
      else      
          # STDIN limitada a 1 caractere.
          # Ou seja opção 10 11 20 50 não funciona e sim de 0-9.
          # Isto para quando a pessoa apertar o número já ir automaticamente
          # sem necessitar do enter.
          read -n 1 -p $'\n' operation
      fi

      # Checando se a entrada é numeral.
      if ! [ "$operation" -eq "$operation" ] 2>/dev/null; then
          echo "Somente números."
          _SLEEP "$timer"
          continue
      fi
      
      # Convertendo toda entrada em minusculo
      show_me[$operation]=${show_me[$operation],,}

      # sedzinho básico para remover alguns caracteres e converter o que
      # não precisamos.
      show_me[$operation]=$(
           echo "${show_me[$operation]}" |
           sed '
             s/áÁàÀãÃâÂéÉêÊíÍóÓõÕôÔúÚüÜçÇ/aAaAaAaAeEeEiIoOoOoOuUuUcC/ ;
             s/[,.;?!]//g ;                           
             s/^[[:space:]]*//;                           
             s/ /-/g;
             s/\r//g'
      )

      ( # Abertura de subshell
         cd "$sound" # Entrando no diretório sons
         # Verificando se arquivo existe
         if [ ! -e "${show_me[$operation]}.ogg" ]; then
             echo -e "\n${show_me[$operation]} não encontrado no diretório ${dir[0]}."
             _SLEEP "$timer"
             return 1
         fi
         paplay ${show_me[$operation]}.ogg # Tudo ocorreu bem? Então toca.
      )
   done # Loop principal
}

#================= INICIO
# Ajuda foi chamada?
[ "$1" = "-h" ] || [ "$1" = "--help" ] && { _PRINT "${dir[1]}/help.txt"; exit 0;}

# Imprimir o logo de inicio?
if [ "$show_me_logo" = '0' ]; then
   cat "${dir[3]}/${logo}.logo" # Printa pra noix
   if [ "$show_me_slogan" = "0" ]; then # efeito write ta habilitado?
       echo "$slogan" | pv -qL 20 # Imprimindo slogan
   else
       echo "$slogan"
   fi
   timer=$(($timer-1)) # Diminuindo tempo para o sleep.
   sleep "$timer"
fi

# Chamando programa.
[ "$1" = "" ] && _MAIN

