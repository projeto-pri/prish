#!/usr/bin/env bash
#==========================HEADER====================================|
#AUTOR
# Jefferson 'slackjeff' Rocha <root@slackjeff.com.br>
#
#LICENÇA
# MIT
#
#PROGRAMA
# prish - Dê voz a quem precisa.
#
#DOCUMENTAÇÃO
# Leia a documentação completa que se encontra externamente
#
#CHANGELOG
# Visualize o arquivo CHANGELOG.md para saber mais!
#====================================================================|

#================= BIBLIOTECAS
. prish.conf          # Carregando arquivo de configuração do sistema

#================= CONSTANTES

BLACK='\e[30;1m'		# Preto
RED='\e[31;1m'			# Vermelho
GREEN='\e[32;1m'		# Verde
YELLOW='\e[33;1m'		# Amarelo
BLUE='\e[34;1m'			# Azul
PINK='\e[35;1m'			# Rosa
CYAN='\e[36;1m'			# Ciano
WHITE='\e[37;1m'		# Branco

RED_WHITE='\e[37;41;1m'		# Vermelho e Branco
BLUE_WHITE='\e[37;44;1m'	# Azul e Branco
YELLOW_BLACK='\e[30;43m'	# Amarelo e Preto
BLACK_YELLOW='\e[33;40;1m'	# Preto e Amarelo
GREEN_RED='\e[31;42;1m'		# Verde e Vermelho
CYAN_BLACK='\e[30;46;1m'	# Ciano e Preto

END='\e[m'			# Fechamento das cores

#================= VARIÁVEIS
name='prish'              # Nome do Projeto
version='1.0a'             # Versão

#================= TEST
# Carregamento de variáveis!
# Caso as variáveis de ambiente da prish não estão
# com suas respectivas numerações/chaves por falta
# de atenção do usuário, elas carregarão como padrão definidas.
[[ "$limit_menu" =~ [0-9] ]]   ||  limit_menu="${LIMIT_MENU:-9}"
[[ "$timer" =~ [0-9] ]]        ||  timer="${TIMER:-2}"
[[ "$color_key" =~ [0-9] ]]    ||  color_key="${COLOR_KEY:-0}"
[[ "$color_number" =~ [0-9] ]] ||  color_number="${COLOR_NUMBER:-1}"
[[ "$color_text" =~ [0-9] ]]   ||  color_text="${COLOR_TEXT:-7}"

# Utilizar cores na saída?
# Se sim vamos puxar qual o valor o usuario(a) definiu
# no arquivo de configuração.
if [ "$color_key" = "0" ]; then
   case $color_number in		# Fundo/cor Númerico
       1) bgmenu=${RED_WHITE};;		# Fundo Vermelho com letra Branca
       2) bgmenu=${BLUE_WHITE};;	# Fundo Azul com letra Branca
       3) bgmenu=${YELLOW_BLACK};;	# Fundo Amarelo com letra Preta
       4) bgmenu=${BLACK_YELLOW};;	# Fundo Preto com letra Amarela
       5) bgmenu=${GREEN_RED};;		#Fundo Verde com letra Vermelha
       6) bgmenu=${CYAN_BLACK};;	# Fundo Cyano com letra Preta
   esac
   case $color_text in # Cor texto
      1) txtcolor=${BLACK};;		# Preto
      2) txtcolor=${RED};;		# Vermelho
      3) txtcolor=${GREEN};;		# Verde
      4) txtcolor=${YELLOW};;		# Amarelo
      5) txtcolor=${BLUE};;		# Azul
      6) txtcolor=${PINK};;		# Rosa
      7) txtcolor=${CYAN};;		# Ciano
      8) txtcolor=${WHITE};;		# Branco
   esac
   endcolor=${END}			# Fechamento da cor.
fi


# Conferindo se todos os diretórios principais existem!
# Ao decorrer do program está lista é usada para ir criando
# variáveis.
dir=(
    "sons"
    "documentacao"
    "modulo"
    "logo"
)

for check_dir in "${dir[@]}"; do
    [ ! -d "$check_dir" ] && { echo "Diretório '$check_dir' não foi encontrado!"; exit 1;}
done

# Verificando se as deps estão supridas
# Adicione no vetor conforme ira aumentando
# as dependencias da pri.
dep=(
   'paplay'
   'pv'
)

# Loop para varrer a array atrás das deps.
for check in "${dep[@]}"; do
    if ! type "$check" &>/dev/null; then
        echo "Falta instalar a dependência ${check}."
        exit 1
    fi
done

# Verificando qual o gênero da voz será usado.
# Se não for setado nada o padrão é o masculino.
voice=$(echo "$voice" | tr [A-Z] [a-z] ) # Tudo em lower
if [ "$voice" = "m" ]; then
    sound="${dir[0]}/masculino/"
elif [ "$voice" = "f" ]; then
    sound="${dir[0]}/feminino/"
else
    sound="${dir[0]}/masculino"
fi

#================= FUNCÕES

_PRINT() # Função de printa na tela
{
   while IFS= read view; do
      echo "$view"
   done < "$*"
}

_SLEEP() # Função para adormecer em determinados momentos.
{
   sleep "$@"
}

_PRINT_ME()
{
   i='0' # var de incremento.
   clear
   echo -e "         \e[36;1m$mylocal\e[m"  
   echo "└─────────────────────────┘"
   echo

   # Printando na tela
   while IFS= read print_me; do
       i=$((i+1))
       echo -e "${bgmenu}[ ${i} ]${endcolor} ${txtcolor} $print_me ${endcolor}" # Imprimindo com incremento.
       show_me[$i]="$print_me" # pegando no vetor todas opções
       [ "$i" = "$limit_menu" ] && break # Verficando o limite máximo do menu.
   done < "$*"
}

_MAIN() # Função que faz a rotina principal
{
   dir="modulo" # Diretório principal dos modulos
   mod_dir=(    # Lista das bibliotecas de submenus
       "${dir}/principal.lib"   # 0
       "${dir}/basico.lib"      # 1
       "${dir}/saudacoes.lib"   # 2
       "${dir}/sentimentos.lib" # 3
       "${dir}/perguntas.lib"   # 4
       "${dir}/respostas.lib"   # 5
       "${dir}/dor.lib"         # 6
       "${dir}/eu-quero.lib"    # 7
       "${dir}/eu-preciso.lib"  # 8 
   )
   
   # lista do menu principal para inserir
   # dentro da var choice, logo abaixo!
   imhere=(
       "Principal"    # 0
       "Básico"       # 1
       "Saudações"    # 2
       "Sentimentos"  # 3
       "Perguntas"    # 4
       "Respostas"    # 5
       "Dor"          # 6
       "Eu Quero"     # 7
       "Eu Preciso"   # 8
   )   

   while :; do
      # Iniciando Var de localização que é exibido
      # em cima do menu.
      mylocal="Principal"
      choice="${mod_dir[0]}" # Menu principal.
      # Verificando se chaves estão ligadas.
      clear # Limpa a tela ae
      _PRINT_ME "$choice" # Função para printar na tela.
      # STDIN limitada a 1 caractere.
      # Ou seja opção 10 11 20 50 não funciona e sim de 0-9.
      # Isto para quando a pessoa apertar o número já ir automaticamente
      # sem necessitar do enter.
      read -n 1 -p $'\n' operation

      # Checando se a entrada é numeral.
      if ! [ "$operation" -eq "$operation" ] 2>/dev/null; then
          echo "Somente números."
          _SLEEP "$timer"
          continue
      fi
      # Verificando qual opção o usuário escolheu
      # e tbm indicando a localização do usuário
      case $operation in
          1) choice="${mod_dir[1]}"; mylocal="${imhere[1]}";;
          2) choice="${mod_dir[2]}"; mylocal="${imhere[2]}";;
          3) choice="${mod_dir[3]}"; mylocal="${imhere[3]}";;
          4) choice="${mod_dir[4]}"; mylocal="${imhere[4]}";;
          5) choice="${mod_dir[5]}"; mylocal="${imhere[5]}";;
          6) choice="${mod_dir[6]}"; mylocal="${imhere[6]}";;
          7) choice="${mod_dir[7]}"; mylocal="${imhere[7]}";;
          8) choice="${mod_dir[8]}"; mylocal="${imhere[8]}";;
      esac
      
      _PRINT_ME "${choice}"
      read -n 1 -p $'\n' operation
      # Convertendo toda entrada em minusculo
      show_me[$operation]=${show_me[$operation],,}

      # sedzinho básico para remover alguns caracteres e converter o que
      # não precisamos.
      show_me[$operation]=$(
           echo "${show_me[$operation]}" |
           sed '
             y/áÁàÀãÃâÂéÉêÊíÍóÓõÕôÔúÚüÜçÇ/aAaAaAaAeEeEiIoOoOoOuUuUcC/ ;
             s/[,.;?!]//g ;                           
             s/^[[:space:]]*//;                           
             s/ /-/g;
             s/\r//g'
      )

      ( # Abertura de subshell
         cd "$sound" # Entrando no diretório sons
         # Verificando se arquivo existe
         if [ ! -e "${show_me[$operation]}.ogg" ]; then
             echo -e "\n${show_me[$operation]} não encontrado no diretório ${dir[0]}."
             _SLEEP "$timer"
             return 1
         fi
         paplay ${show_me[$operation]}.ogg & # Tudo ocorreu bem? Então toca.
      )
   done # Loop principal
}

#================= INICIO
# Ajuda foi chamada?
[ "$1" = "-h" ] || [ "$1" = "--help" ] && { _PRINT "${dir[1]}/help.txt"; exit 0;}

# Imprimir o logo de inicio?
if [ "$show_me_logo" = '0' ]; then
   cat "${dir[3]}/${logo}.logo" # Printa pra noix
   if [ "$show_me_slogan" = "0" ]; then # efeito write ta habilitado?
       paplay "${dir[0]}/ambiente/entrada.ogg" &
       echo "$slogan" | pv -qL 12 # Imprimindo slogan
       sleep 1s
   else
       echo "$slogan"
   fi
   timer=$(($timer-1)) # Diminuindo tempo para o sleep.
   sleep "$timer"
fi
clear
# Chamando programa.
[ "$1" = "" ] && _MAIN

